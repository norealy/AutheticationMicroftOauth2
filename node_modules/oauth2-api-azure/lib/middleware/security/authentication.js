"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_session_1 = __importDefault(require("express-session"));
const passport_1 = __importDefault(require("passport"));
const adal_node_1 = require("adal-node");
const token_helpers_1 = require("./token-helpers");
const routes_1 = require("../../routes");
const Logging_1 = require("../../middleware/utilities/Logging");
const HttpErrorHandler_1 = require("../utilities/HttpErrorHandler");
const types_1 = require("../../types");
const microsoft_graph_client_1 = require("@microsoft/microsoft-graph-client");
// MSGraph Resource
const graphResourceId = "https://graph.microsoft.com";
// the MSGraph API endpoint to get all groups in Azure AD
const groupsGraphUrl = "https://graph.microsoft.com/v1.0/groups";
// the MSGraph API endpoint to get all members of the particular group
const groupMemberGraphUrlTemplate = "https://graph.microsoft.com/v1.0/groups/{0}/members";
class OAuthMiddleware {
    constructor(authSettings, passportOptions, hostname, baseAuthRoute) {
        this.authRedirectUri = `${hostname}${baseAuthRoute}/oauth/getAToken`;
        this.signInUrl = `${hostname}${baseAuthRoute}/oauth/signin`;
        this.refreshTokenUrl = `${hostname}${baseAuthRoute}/oauth/refreshToken`;
        this.authSettings = authSettings;
        this.passportAuthOptions = passportOptions;
        this.baseAuthRoute = baseAuthRoute;
        this.app = null;
    }
    setAppHandler(app) {
        try {
            this.app = app;
            // Must use session for storing auth values
            this.app.use(express_session_1.default({
                secret: "api-oauth-azure",
                resave: false,
                saveUninitialized: true,
            }));
            if (this.baseAuthRoute === undefined || this.baseAuthRoute.length === 0) {
                throw new Error("Missing base API Uri");
            }
            // initialize OAuth routers
            const authRouter = new routes_1.AuthRouter(this.baseAuthRoute);
            authRouter.addAuthRoutes();
            // add the OAuth router to the express app
            this.app.use(this.baseAuthRoute, authRouter.getRouter());
            return this.app;
        }
        catch (error) {
            Logging_1.Logger.trackException(error);
            throw error;
        }
    }
    authenticate(securityStrategy) {
        return (request, response, next) => __awaiter(this, void 0, void 0, function* () {
            if (!request.session) {
                // return to the error handler
                return next(HttpErrorHandler_1.HttpErrorHandler.Unauthorized("Session cookies must be enabled"));
            }
            switch (securityStrategy) {
                case types_1.SecurityStrategies.BEARER:
                    // Check if the request contains the authorization header,
                    // if it does, then go straight to the passport authentication
                    // otherwise, check if the user has already been signed in by
                    // checking the request session's accessToken
                    if (!request.headers.authorization && request.session.accessToken) {
                        request.headers.authorization =
                            "Bearer " + request.session.accessToken;
                    }
                    if (request.headers.authorization) {
                        try {
                            yield passport_1.default.authenticate(securityStrategy, this.passportAuthOptions, (req, err, authInfo) => {
                                if (authInfo && authInfo.oid !== undefined) {
                                    next();
                                }
                                else {
                                    // return to the error handler
                                    return next(HttpErrorHandler_1.HttpErrorHandler.Unauthorized(authInfo));
                                }
                            })(request);
                        }
                        catch (error) {
                            response.status(401);
                            next(error);
                        }
                    }
                    else if (request.session.authCode) {
                        // If the user has already been signed in,
                        // try to obtain the JWT token with the claims
                        // that would allow accessing the Data API resource
                        try {
                            const authInfo = yield this.getAccessTokenSilently(this.authSettings.apiAppId, request.session.authCode);
                            return this.tokenResponseHandler(authInfo, request, response);
                        }
                        catch (error) {
                            if (request.session) {
                                if (request.session.authCode !== request.session.refresh_token) {
                                    // Refresh Auth token and try again
                                    return response.redirect(this.refreshTokenUrl);
                                }
                                else {
                                    return next(HttpErrorHandler_1.HttpErrorHandler.Unauthorized());
                                }
                            }
                        }
                    }
                    else if (request.session.useClientCredentials) {
                        // If the user has already been signed in,
                        // try to obtain the JWT token with the claims
                        // that would allow accessing the Data API resource
                        try {
                            const authInfo = yield this.getAccessTokenSilently(this.authSettings.apiAppId);
                            return this.tokenResponseHandler(authInfo, request, response);
                        }
                        catch (error) {
                            // Refresh Auth token and try again
                            return response.redirect(this.signInUrl);
                        }
                    }
                    else {
                        // Redirect user/app to the sign-in page
                        return response.redirect(this.signInUrl);
                    }
                    break;
                case types_1.SecurityStrategies.AUTH_CODE:
                    // If user's auth code is provided in the header,
                    // then verify the token and continue to the next middleware
                    if (request.headers["x-auth-code"] || request.session.authCode) {
                        const authCode = request.session.authCode ||
                            request.headers["x-auth-code"];
                        // If the user has already been signed in,
                        // try to obtain the JWT token with the claims
                        // that would allow accessing the API resource
                        try {
                            const authInfo = (yield this.getAccessTokenSilently(this.authSettings.apiAppId, authCode));
                            if (token_helpers_1.validateAudience(authInfo.accessToken, this.authSettings.apiAppId)) {
                                // If the user has been successfully authenticated,
                                // grant access to the requested API endpoint
                                next();
                            }
                            else {
                                return next(HttpErrorHandler_1.HttpErrorHandler.Unauthorized());
                            }
                        }
                        catch (error) {
                            if (error.error_codes.find(c => c === 54005)) {
                                // the OAuth code has already been redeemed
                                // grant access to the requested API endpoint
                                next();
                            }
                            else {
                                return next(HttpErrorHandler_1.HttpErrorHandler.Unauthorized(error.message));
                            }
                        }
                    }
                    else {
                        // If user hasn't been authenticated yet,
                        // redirect to the sign-in flow
                        request.session.redirectUrl = request.originalUrl;
                        // Redirect to the sign-in api
                        return response.redirect(this.signInUrl);
                    }
                    break;
                default:
                    return next(HttpErrorHandler_1.HttpErrorHandler.Unauthorized());
            }
        });
    }
    getAccessTokenSilently(resourceId, authCode) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const authorityUrl = `https://login.microsoftonline.com/${this.authSettings.tenant}`;
                    const authContext = new adal_node_1.AuthenticationContext(authorityUrl);
                    if (authCode) {
                        // Attempt to obtain the OAuth token using user's credentials
                        yield authContext.acquireTokenWithAuthorizationCode(authCode, this.authRedirectUri, resourceId, this.authSettings.clientId, this.authSettings.clientSecret, (err, res) => {
                            if (err) {
                                Logging_1.Logger.trackException(err);
                                reject(res);
                            }
                            resolve(res);
                        });
                    }
                    else {
                        // If authCode is not provided, attempt to obtain the OAuth token using client credentials
                        yield authContext.acquireTokenWithClientCredentials(resourceId, this.authSettings.clientId, this.authSettings.clientSecret, (err, res) => {
                            if (err) {
                                Logging_1.Logger.trackException(err);
                                reject(err);
                            }
                            resolve(res);
                        });
                    }
                }
                catch (error) {
                    Logging_1.Logger.trackException(error);
                    reject(error);
                }
            }));
        });
    }
    getAllADGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // obtain the JWT token for accessing MS Graph API
                const authInfo = (yield this.getAccessTokenSilently(graphResourceId));
                const client = yield this.getGraphClient(authInfo.accessToken);
                const graphResponse = yield client.api(groupsGraphUrl).get();
                const groups = graphResponse.value;
                return groups;
            }
            catch (error) {
                Logging_1.Logger.trackException(error);
                return Promise.reject(error.message);
            }
        });
    }
    findIfUserIsMemberOfGroup(groupId, userDisplayName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // obtain the JWT token for accessing MS Graph API
                const authInfo = (yield this.getAccessTokenSilently(graphResourceId));
                const client = yield this.getGraphClient(authInfo.accessToken);
                const groupMemberGraphUrl = groupMemberGraphUrlTemplate.replace("{0}", groupId);
                const graphRes = yield client.api(groupMemberGraphUrl).get();
                const dirGroups = graphRes.value;
                if (dirGroups) {
                    // iterate through the all groups
                    dirGroups.forEach(group => {
                        if (group.displayName === userDisplayName) {
                            return Promise.resolve(true);
                        }
                    });
                }
                return Promise.resolve(false);
            }
            catch (error) {
                Logging_1.Logger.trackException(error);
                return Promise.reject(error.message);
            }
        });
    }
    /////////////////////////////////////////////////////////////////////
    // Private Methods
    tokenResponseHandler(res, request, response) {
        const authInfo = res;
        if (request.query.authInfo) {
            response.send(`UserId:${authInfo.userId}\nObjectId:${authInfo.oid}\nAccessToken=${authInfo.accessToken}`);
        }
        else if (request.session) {
            // Add the access token to the response cookie and
            // then perform the call to the original API endpoint
            request.session.accessToken = authInfo.accessToken;
            request.session.redirectUrl = request.originalUrl;
            return response.redirect(request.session.redirectUrl);
        }
        else {
            response.send(authInfo.accessToken);
        }
    }
    getGraphClient(accessToken) {
        return __awaiter(this, void 0, void 0, function* () {
            return microsoft_graph_client_1.Client.init({
                authProvider: done => {
                    done(null, accessToken);
                },
            });
        });
    }
}
exports.OAuthMiddleware = OAuthMiddleware;
//# sourceMappingURL=authentication.js.map