"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const passport_1 = __importDefault(require("passport"));
const passport_azure_ad_1 = __importDefault(require("passport-azure-ad"));
__export(require("./types"));
__export(require("./routes"));
__export(require("./middleware/security/authentication"));
// max amount of state/nonce cookie you want to keep (cookie is deleted after validation so this can be very small)
exports.NonceMaxAmount = 5;
// state/nonce cookie expiration in seconds
exports.NonceLifetime = 600;
function authInit(authSettings, passToRBACCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        const oidsOptions = {
            identityMetadata: `https://login.microsoftonline.com/${authSettings.tenant}/.well-known/openid-configuration`,
            clientID: authSettings.clientId,
            responseType: "code id_token",
            responseMode: "form_post",
            redirectUrl: `${authSettings.redirectUri}/oauth/getAToken`,
            allowHttpForRedirectUrl: authSettings.allowHttpForRedirectUrl,
            clientSecret: authSettings.clientSecret,
            validateIssuer: authSettings.validateIssuer,
            isB2C: authSettings.isB2C,
            issuer: authSettings.issuer,
            passReqToCallback: true,
            scope: authSettings.scope,
            loggingLevel: authSettings.loggingLevel,
            loggingNoPII: authSettings.logginNoPII,
            nonceLifetime: exports.NonceLifetime,
            nonceMaxAmount: exports.NonceMaxAmount,
            useCookieInsteadOfSession: false,
        };
        // set up AD OAth v2 authentication
        const bearerStrategyOptions = {
            identityMetadata: "https://login.microsoftonline.com/" +
                authSettings.tenant +
                "/.well-known/openid-configuration",
            clientID: authSettings.clientId,
            audience: authSettings.apiAppId,
            validateIssuer: authSettings.validateIssuer,
            issuer: authSettings.tenant,
            loggingNoPII: authSettings.logginNoPII,
            passReqToCallback: true,
            loggingLevel: authSettings.loggingLevel,
        };
        const bearerStrategy = new passport_azure_ad_1.default.BearerStrategy(bearerStrategyOptions, (req, token, done) => {
            if (token) {
                // Validate user's permissions
                passToRBACCallback(token.oid, // ID uniquely identifying the user across applications.
                token.iss, // A security token service (STS) URI
                token.scp, // The set of scopes
                token.roles, req.session ? req.session.redirectUrl : null, (err, usr) => {
                    if (err) {
                        return done(err);
                    }
                    if (!usr) {
                        // "No User found"
                        return done(new Error("No valid user found"));
                    }
                    done(null, {}, token);
                });
            }
        });
        passport_1.default.use(bearerStrategy);
        const oidcStrategy = new passport_azure_ad_1.default.OIDCStrategy(oidsOptions, (request, iss, sub, user, jwtClaims, access_token, refresh_token, params, done) => __awaiter(this, void 0, void 0, function* () {
            if (!user.oid) {
                return done(new Error("No OID found"), null);
            }
            // Save authorization code and refresh tokens in the session cookies
            if (request.session) {
                // redirect to the requested resource
                request.session.idToken = request.body.id_token;
                request.session.authCode = request.body.code;
                request.session.access_token = access_token;
                request.session.refresh_token = refresh_token;
            }
            // Validate user's permissions
            yield passToRBACCallback(request, user, iss, sub, jwtClaims, params, request.session ? request.session.redirectUrl : null, (err, usr) => {
                if (err) {
                    return done(err);
                }
                if (!usr) {
                    // "No User found"
                    return done(new Error("No valid user found"));
                }
                if (request.session !== undefined && request.res !== undefined) {
                    // redirect to the requested resource
                    request.res.redirect(request.session.redirectUrl);
                }
                else {
                    return done(err);
                }
            });
        }));
        passport_1.default.use(oidcStrategy);
    });
}
exports.authInit = authInit;
//# sourceMappingURL=index.js.map